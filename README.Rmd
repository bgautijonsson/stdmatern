---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```


# stdmatern

This directory is for development of fast and memory-efficient code that creates Mat√©rn precision matrices that have been standardized so that their inverse is a correlation matrix. The code is written in C++ and made available inside R with the `{Rcpp}` packages.

The package can be installed with 

```{r}
#| eval: false
pak::pak("bgautijonsson/stdmatern")
```



```{r}
library(stdmatern)
Q <- make_standardized_matern(dim = 3, rho = 0.5, nu = 0)
```

```{r}
Q
```

```{r}
Q |> solve()
```

Creating and standardizing a 1600x1600 precision matrix

```{r}
bench::mark(
  make_standardized_matern(dim = 40, rho = 0.5, nu = 0)
)
```


# Sampling spatial data


```{r}
#| include: false
#| echo: true
library(dplyr)
library(sparseMVN)
library(ggplot2)
```

Here we sample highly dependent spatial data on a 100x100 grid, i.e. there's 10.000 observational locations.

```{r}
start <- tictoc::tic()
grid_dim <- 100
rho <- 0.9
nu <- 2
Z <- sample_standardized_matern(grid_dim, rho, nu, 1)

tibble(
  Z = as.numeric(Z)
) |> 
  mutate(
    id = row_number(),
    lat = (id - 1) %% grid_dim,
    lon = cumsum(lat == 0),
  ) |> 
  ggplot(aes(lat, lon, fill = Z)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_fixed(expand = FALSE)
stop <- tictoc::toc()
```


# Normal density

The package also implements a method for calculating the log-density of a multivariate normal with appropriate precision matrix. The function avoids creating the precision matrix Q by using known results about kroncker sums and eigendecompositions. This causes the density evaluation to be blazingly fast, even for very large spatial fields.

```{r}
library(purrr)
library(glue)
my_fun <- function(dim) {
  x <- sample_standardized_matern(dim, 0.5, 0, 1)
  bench::mark(
    matern_mvn_density(x, dim, 0.5, 0),
    filter_gc = FALSE,
    iterations = 10,
    check = FALSE
  ) |> 
    mutate(
      dim = dim
    )
}

results <- map(c(10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 200), my_fun)

results |> 
  list_rbind() |> 
  select(Q_size = dim,time = median, memory = mem_alloc) |> 
  mutate(
    Field_size = glue("{Q_size^2} locations"),
    Q_size = glue("{Q_size^2}x{Q_size^2}")
  ) |> 
  select(Field_size, Q_size, time)
```