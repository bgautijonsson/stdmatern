---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```


# stdmatern

This directory is for development of fast and memory-efficient code that creates Matérn precision matrices that have been standardized so that their inverse is a correlation matrix. The code is written in C++ and made available inside R with the `{Rcpp}` packages.

The package can be installed with 

```{r}
#| eval: false
pak::pak("bgautijonsson/stdmatern")
```



```{r}
library(stdmatern)
Q <- make_standardized_matern(dim = 2, rho = 0.5, nu = 0)
```

```{r}
Q
```

```{r}
Q |> solve()
```

# Sampling spatial data


```{r}
#| include: false
#| echo: true
library(dplyr)
library(sparseMVN)
library(ggplot2)
```

Here we sample highly dependent spatial data on a 100x100 grid, i.e. there's 10.000 observational locations.

```{r}
start <- tictoc::tic()
dim <- c(100, 100)
rho <- c(0.4, 0.95)
nu <- 2
Z <- rmatern_copula(1, dim, rho, nu)

tibble(
  Z = as.numeric(Z)
) |> 
  mutate(
    id = row_number(),
    lat = (id - 1) %% dim[1],
    lon = cumsum(lat == 0),
  ) |> 
  ggplot(aes(lat, lon, fill = Z)) +
  geom_raster() +
  scale_fill_viridis_c() +
  coord_fixed(expand = FALSE)
stop <- tictoc::toc()
```


# Normal density

The package also implements a method for calculating the log-density of a multivariate normal with appropriate precision matrix. The function avoids creating the precision matrix Q by using known results about kroncker sums and eigendecompositions. This causes the density evaluation to be blazingly fast, even for very large spatial fields.

The package also contains functions for sampling from and calculating densities for regular Matérn-like fields where the marginal variances don't have to be equal to one. Those functions are even faster than the copula versions.

```{r}
library(purrr)
library(glue)
library(tinytable)
library(tidyr)

my_fun <- function(dim) {
  x_copula <- rmatern_copula(1, dim, dim, 0.5, 0)
  x <- rmatern(1, dim, dim, 0.5, 0)
  bench::mark(
    "Copula" = dmatern_copula_eigen(x, dim, dim, 0.5, 0),
    "Regular" = dmatern_eigen(x, dim, dim, 0.5, 0),
    filter_gc = FALSE,
    iterations = 10,
    check = FALSE
  ) |> 
    mutate(
      dim = dim
    )
}

results <- map(seq(10, 200, by = 10), my_fun)


results |> 
  list_rbind() |> 
  select(Q_size = dim, type = expression, time = median, memory = mem_alloc) |> 
  mutate(
    Q_size = glue("{Q_size^2}x{Q_size^2}"),
    type = as.character(type),
    time = as.character(time)
  ) |> 
  select(-memory) |> 
  pivot_wider(names_from = type, values_from = time) |> 
  tt()
```